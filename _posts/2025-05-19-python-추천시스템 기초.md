---
layout: post
title:  "추천시스템 기초 조사" 
subtitle:   "추천시스템 기초 조사"
categories: Python
tags: RS
comments: true
---

## 추천시스템에 대한 기본 정보를 남긴 포스팅 입니다.

<br/>

### 1. 필터링 method

##### Contents-Based Filtering(컨텐츠 기반 필터링) :

말 그대로 컨텐츠 기반의 추천 알고리즘

TF-IDF, Word2Vec, Similarity 활용하여

사용자가 로맨스 영화에 높은 평점을 좋았으면 다른 로맨스 영화를 추천해주는 단순한 방식 

장점 : 콜드 스타트 문제 해결 가능

단점 : 메타 정보의 한정성, 개인 성향 세부적 파악 어려움

<br/>

##### Collaborative Filtering(협업 필터링) :

아이템 평점, 상품 구매 이력 등 "사용자 행동 양식" 기반 추천

A. Memory-Based Approach

- user based(사용자 기반) : 비슷한 취향 사람들의 이웃 선택 (평점 유사도 기반)

- item based(아이템 기반) : 특정 item 선택 -> 그 사용자들이 공통적으로 좋아한 다른 item 찾음 등

방법 : Cosine Similarity, Pearson Correlation (혹은 KNN) 등

장점 : 쉽게 생산 & 결과 설명력 좋음 & 도메인 의존적 x

단점 : 데이터 축적 x or Sparse 한 경우 성능이 낮음 & 확장 가능성 적음 

(+ 데이터 너무 많으면 속도 저하 됨.)

<br/>

B. Model-Based Approach

특징 : 기계학습 이용 & 최적화 방법 or 매개변수를 학습

방법 : "행렬 분해(Matrix Factoriztion)", SVD, 신경망 모델

장점 : Sparse한 데이터 처리 가능, 초기 모델 구축 후 Inference도 쉽게 가능.

단점 : 결과 설명력 낮음, 초기 모델 Training 연산이 오래 걸림

<br/>

- cf. 행렬 분해(Matrix Factoriztion)

[관련 tutorial](https://lazyprogrammer.me/tutorial-on-collaborative-filtering-and-matrix-factorization-in-python/)

장점 : 선형적 곱하는 단순한 방법으로 매우 효율적임.

단점 : User, Item 사이의 복잡한 비 선형적 상호관계를 모델링 하기에는 불충분할 수 있음.

- 해결안 1. 더 높은 차원의 latent space 도입 (축 1개 추가) 하면 더 복잡한 표현 가능

-> 그럼 모델의 일반화 성능이 저해 됨. -> 비추천

- 해결안 2. 비선형적 관계 모델링이 가능한 신경망 활용 시, 복잡한 상호 관계 적용 가능.

[관련 포스팅]()


내용 작성 필요

```python

  logits = model(images, training=True) #dropout 적용
  loss = tf.reduce_mean(tf.keras.losses.categorical_crossentropy(y_pred = logits,
                                                                y_true = labels, from_logits = True))
  def grad(model, images, labels):
    with tf.GradientTape() as tape:
      loss = loss_fn(model, images, labels)
    return tape.gradient(loss, model.variables)             

  def train(model, images, labels):
    grads = grad(model, images, labels)
    optimizer.apply_gradients(zip(grads, model.trainable_variables))                                                 

```








<br/>

C. 한계점

1. 콜드 스타트(Cold Start)

: 데이터가 중요함.(User-Item 행렬이 충분히 구축 되어야 함.)

- user-based : 신규 사용자 행동 기록 없으면, 어떠한 아이템도 추천 x.

- item based : 신규 상품이 출시 되더라도 추천 x.

-> 시스템이 충분한 정보를 갖고 있지 않다면 추천 불가함.

2. 계산 효율성 저하 

: 사용자가 많아질수록 계산 시간 증가. 근데 사용자가 많아야지 정확한 추천 결과가 나타남.

3. Long-Tail 문제

: 파레토 법칙 (전체 결과의 80%가 전체 원인의 20%에서 발생되는 현상)

-> 사용자들이 관심 가지는 소수 인기 콘텐츠를 주로 추천함.

-> 품질 좋은 아이템은 추천되지 못하고 "추천의 다양성"이 떨어짐.

<br/>